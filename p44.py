#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
module: p44.py
author: Zach Lamberty
created: 2014-03-09

Description:
    Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first
    ten pentagonal numbers are:

        1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

    It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference,
    70 − 22 = 48, is not pentagonal.

    Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
    difference are pentagonal and D = |Pk − Pj| is minimised; what is the value
    of D?

Notes:
    Tough one!!

    Basically, my approach will be this: step up through possible pentagonal
    differences (easy). This defines a maximum difference. Then, step up
    through possible P_i (minimum defined by the index of the differnece,
    maximum defined by the first i for with P_i - P_{i + 1} is greater than D),
    and for each step down in P_j until the difference is again larger than D.
    Increase d until you've found your magic little guy.

"""

import argparse

from itertools import combinations
from math import sqrt
from operator import add, sub


def pentagonal(d):
    """ durt """
    return d * (3 * d - 1) / 2


def pentagonal_index(P):
    """ return the index for pentagonal number P """
    return (1 + sqrt(1 + 24 * P)) / 6


def is_pentagonal(P):
    """ Check if a number is pentagonal. Since a number is pentagonal iff

            3n**2 - n - 2*P == 0

        or if there is an integer root

            n = (1 + sqrt(1 + 24P)) / 6

        This is integer only if (1 + 24P) is a perfect square.

        Check here:
        http://www.divye.in/2012/07/how-do-you-determine-if-number-n-is.html
        for Notes
    """
    return sqrt(1 + 24 * P) % 6 == 5


def i_range(Pd):
    """ the acceptable values of i to check for our identity """
    return xrange(i_min(Pd), i_max(Pd) + 1)


def i_min(Pd):
    """ Assuming Pi - Pj = Pd *AND* Pi > Pj > Pd, Pi > 2*Pd """
    return int(pentagonal_index(2 * Pd))


def i_max(P):
    return (P + 2) / 6


def is_super_magic_time(Pi, Pj, Pd):
    """ Check first if Pi - Pj == Pd, then if their sum is pentagonal. If so,
        we major

    """
    return (Pi - Pj == Pd) and is_pentagonal(Pi + Pj)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--fast', action="store_true", default=False)
    parser.add_argument('--correct', action="store_true", default=False)
    return parser.parse_args()


if __name__ == '__main__':

    args = parse_args()

    if args.fast:
        pentagonals = set(pentagonal(n) for n in range(1, 3000))
        c = combinations(pentagonals, 2)
        for p in c:
            if add(*p) in pentagonals and abs(sub(*p))in pentagonals:
                Pi, Pj = sorted(p)
                i, j = pentagonal_index(Pi), pentagonal_index(Pj)
                break
    elif args.correct:
        d = 0
        found = False
        while not found:
            d += 1
            Pd = pentagonal(d)
            print 'd = {}, Pd = {}'.format(d, Pd)
            ir = i_range(Pd)
            print '\t{}'.format(ir)
            for i in ir:
                Pi = pentagonal(i)

                # Pj may not be pentagonal
                Pj = Pi - Pd
                if is_pentagonal(Pj) and (is_pentagonal(Pd + 2 * Pj) or is_pentagonal(Pj + 2 * Pd)):
                    j = int(pentagonal_index(Pj))
                    found = True
                    break

    if args.fast or args.correct:
        print 'P_{} = {}'.format(i, Pi)
        print 'P_{} = {}'.format(j, Pj)
        print 'P_{} = {}'.format(d, Pd)
        print 'D = |P_{} - P_{}| = {} {} pentagonal'.format(i, j, abs(Pi - Pj), 'is' if is_pentagonal(abs(Pi - Pj)) else 'is not')
        print 'D = |P_{} - P_{}| = {} {} pentagonal'.format(i, d, abs(Pi - Pd), 'is' if is_pentagonal(abs(Pi - Pd)) else 'is not')
        print 'S = P_{} + P_{} = {} {} pentagonal'.format(i, j, Pi + Pj, 'is' if is_pentagonal(Pi + Pj) else 'is not')
        print 'S = P_{} + P_{} = {} {} pentagonal'.format(i, d, Pi + Pd, 'is' if is_pentagonal(Pi + Pd) else 'is not')
